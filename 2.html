<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gesture Real-Tree & Mobile</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; touch-action: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI Layer */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 3; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }

        /* Video Preview - Adaptive */
        #video-wrapper {
            position: absolute; top: 20px; right: 20px; z-index: 2;
            border-radius: 12px; overflow: hidden;
            border: 2px solid rgba(212, 175, 55, 0.5);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.2);
            transition: all 0.3s;
        }
        #video-input { width: 160px; height: 120px; object-fit: cover; transform: scaleX(-1); display: block; }

        /* Controls */
        .controls { pointer-events: auto; text-align: center; margin-bottom: 20px; width: 100%; }
        .btn {
            background: rgba(212, 175, 55, 0.15); border: 1px solid #D4AF37; color: #D4AF37;
            padding: 12px 24px; cursor: pointer; text-transform: uppercase; letter-spacing: 2px;
            border-radius: 30px; font-weight: 600; font-size: 13px;
            backdrop-filter: blur(8px); transition: all 0.3s;
            -webkit-tap-highlight-color: transparent;
        }
        .btn:active, .btn:hover { background: #D4AF37; color: #000; box-shadow: 0 0 20px #D4AF37; }
        
        /* Guide Text */
        #guide {
            color: rgba(255,255,255,0.7); font-size: 13px; line-height: 1.8; pointer-events: none;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
            background: linear-gradient(90deg, transparent, rgba(0,0,0,0.5), transparent);
            padding: 10px; border-radius: 8px;
        }
        .highlight { color: #D4AF37; font-weight: bold; border-bottom: 1px solid rgba(212,175,55,0.5); }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #D4AF37; font-size: 20px; letter-spacing: 4px; z-index: 10; pointer-events: none; transition: opacity 0.5s;
            text-align: center; width: 100%;
        }

        /* Custom Cursor */
        #hand-cursor {
            position: absolute; width: 30px; height: 30px; 
            border: 2px solid #D4AF37; border-radius: 50%; 
            transform: translate(-50%, -50%); z-index: 5; pointer-events: none;
            box-shadow: 0 0 10px #D4AF37, inset 0 0 10px #D4AF37; 
            transition: background 0.2s, transform 0.1s;
            display: none; mix-blend-mode: screen;
        }
        #hand-cursor.active { background: rgba(212, 175, 55, 0.9); transform: translate(-50%, -50%) scale(0.6); }

        /* --- Mobile / Responsive Adjustments --- */
        @media (max-width: 768px) {
            /* Move video to top-left small */
            #video-wrapper { top: 15px; left: 15px; right: auto; border-width: 1px; }
            #video-input { width: 100px; height: 75px; }
            
            /* Move guide to bottom left above button */
            #guide { font-size: 11px; position: absolute; bottom: 80px; left: 10px; width: 200px; background: none; text-align: left; }
            
            /* Button larger for touch */
            .controls { margin-bottom: 30px; }
            .btn { padding: 15px 30px; font-size: 14px; }

            /* Loading text adjustment */
            #loading { font-size: 16px; width: 80%; }
        }
    </style>
</head>
<body>

    <div id="loading">INITIALIZING 3D CHRISTMAS...</div>
    
    <div id="video-wrapper">
        <video id="video-input" playsinline></video>
    </div>
    
    <div id="canvas-container"></div>
    <div id="hand-cursor"></div>

    <div id="ui-layer">
        <div id="guide-container">
            <div id="guide">
                <div><span class="highlight">‚úä Êè°Êã≥</span>: ËÅöÂêàÊàêÊ†ë</div>
                <div><span class="highlight">üñê Âº†ÂºÄ</span>: Êï£ÂºÄÊºÇÊµÆ</div>
                <div><span class="highlight">üëã ÊóãËΩ¨</span>: Âº†ÂºÄÂπ∂ÁßªÂä®ÊâãÊéå</div>
                <div><span class="highlight">üëå ÊçèÂêà</span>: ÊäìÂèñÁÖßÁâáÊîæÂ§ß</div>
            </div>
        </div>
        <div class="controls">
            <input type="file" id="file-input" multiple accept="image/*" style="display: none;">
            <button class="btn" onclick="document.getElementById('file-input').click()">+ ‰∏ä‰º†ÁÖßÁâá (Photo Cloud)</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- 1. CONFIGURATION ---
        const CONFIG = {
            colors: {
                green: 0x1a472a, // Deep Pine Green
                gold: 0xFDB931,  // Metallic Gold
                red: 0x960018,   // Carmine Red
                star: 0xfffec4
            },
            foliageCount: 400, // Green boxes (volume)
            ornamentCount: 150, // Balls/Canes (surface)
            photoSize: 1.8,
            spreadRadius: 18,
            treeHeight: 22,
            treeBaseRadius: 9
        };

        const STATE = {
            mode: 'tree', 
            handVisible: false,
            cursor: { x: 0, y: 0 },
            activePhoto: null,
            isPortrait: window.innerHeight > window.innerWidth
        };

        // --- 2. THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020202, 0.015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        function updateCameraPosition() {
            STATE.isPortrait = window.innerHeight > window.innerWidth;
            // Mobile portrait needs camera further back to see the whole tree
            const targetZ = STATE.isPortrait ? 40 : 28; 
            const targetY = STATE.isPortrait ? 2 : 5;
            // Smoothly move if updating
            gsap.to(camera.position, { z: targetZ, y: targetY, duration: 1 });
        }
        updateCameraPosition();

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Performance opt
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
        scene.add(ambientLight);

        const mainLight = new THREE.PointLight(CONFIG.colors.gold, 1.2, 80);
        mainLight.position.set(10, 20, 15);
        scene.add(mainLight);

        const fillLight = new THREE.PointLight(CONFIG.colors.red, 0.8, 80);
        fillLight.position.set(-15, 0, 10);
        scene.add(fillLight);

        // Ground Reflection (Subtle)
        const planeGeo = new THREE.PlaneGeometry(200, 200);
        const planeMat = new THREE.MeshStandardMaterial({ 
            color: 0x050505, roughness: 0.1, metalness: 0.5 
        });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -CONFIG.treeHeight / 2 - 2;
        scene.add(plane);

        // Bloom
        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.15;
        bloomPass.strength = 1.0;
        bloomPass.radius = 0.6;

        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- 3. REALISTIC TREE GENERATION ---
        const objects = []; 
        const photos = [];
        const raycaster = new THREE.Raycaster();

        // Materials
        const matFoliage = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.green, roughness: 0.9, metalness: 0.1 
        });
        const matGold = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.gold, roughness: 0.1, metalness: 0.9, emissive: 0x221100 
        });
        const matRed = new THREE.MeshStandardMaterial({ 
            color: CONFIG.colors.red, roughness: 0.2, metalness: 0.6 
        });
        const matCane = new THREE.MeshStandardMaterial({
             color: 0xFFFFFF, roughness: 0.4
        });

        const geoBox = new THREE.BoxGeometry(0.6, 0.6, 0.6); // Leaves
        const geoSphere = new THREE.SphereGeometry(0.35, 32, 32); // Ornaments
        const geoCane = new THREE.CylinderGeometry(0.08, 0.08, 1.8, 8);

        function getTreePos(normalizedHeight, isOrnament) {
            // Realistic Tree Logic:
            // 1. Cone Radius varies with height
            // 2. Ornaments stick to the surface (outer radius)
            // 3. Foliage fills the volume (random radius inside max)
            
            const y = normalizedHeight * CONFIG.treeHeight - CONFIG.treeHeight / 2;
            const maxRadius = (1 - normalizedHeight) * CONFIG.treeBaseRadius;
            
            let r;
            if (isOrnament) {
                // Surface: 85% to 105% of radius (slightly varied depth)
                r = maxRadius * (0.85 + Math.random() * 0.2);
            } else {
                // Volume: Square root distribution for uniform density in a circle
                r = maxRadius * Math.sqrt(Math.random()) * 1.1;
            }

            const angle = Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;

            return new THREE.Vector3(x, y, z);
        }

        function createParticles() {
            const total = CONFIG.foliageCount + CONFIG.ornamentCount;

            for (let i = 0; i < total; i++) {
                const isOrnament = i >= CONFIG.foliageCount;
                let mesh;
                
                // Height distribution (more dense at bottom)
                // Using power function to put more items at bottom
                let h = Math.pow(Math.random(), 0.8); // 0 to 1

                if (!isOrnament) {
                    // Foliage
                    mesh = new THREE.Mesh(geoBox, matFoliage);
                    // Randomize box size for organic look
                    const scale = 0.5 + Math.random() * 1.0;
                    mesh.scale.set(scale, scale, scale);
                } else {
                    // Ornaments
                    const rand = Math.random();
                    if (rand < 0.6) {
                         mesh = new THREE.Mesh(geoSphere, Math.random() > 0.5 ? matGold : matRed);
                    } else {
                        mesh = new THREE.Mesh(geoCane, matCane);
                        mesh.rotation.z = Math.PI / 4;
                    }
                }

                // Random scatter position
                const scatterPos = new THREE.Vector3(
                    (Math.random() - 0.5) * CONFIG.spreadRadius * 2,
                    (Math.random() - 0.5) * CONFIG.spreadRadius * 2,
                    (Math.random() - 0.5) * CONFIG.spreadRadius * 1.5
                );

                // Tree position
                const treePos = getTreePos(h, isOrnament);

                mesh.position.copy(scatterPos); // Start scattered (or tree, we animate later)
                // Random Rotation
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                
                scene.add(mesh);

                objects.push({
                    mesh: mesh,
                    treePos: treePos,
                    scatterPos: scatterPos,
                    originalScale: mesh.scale.clone(),
                    isOrnament: isOrnament
                });
            }

            // Move to tree initially
            transitionToTree(0);
        }

        createParticles();

        // Photo Upload Logic
        document.getElementById('file-input').addEventListener('change', function(e) {
            const files = e.target.files;
            if (!files.length) return;

            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const texture = new THREE.Texture(img);
                        texture.needsUpdate = true;
                        createPhotoMesh(texture);
                    };
                };
                reader.readAsDataURL(file);
            });
        });

        function createPhotoMesh(texture) {
            const aspect = texture.image.width / texture.image.height;
            const geo = new THREE.PlaneGeometry(CONFIG.photoSize, CONFIG.photoSize / aspect);
            const mat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geo, mat);
            
            // Gold Border
            const borderGeo = new THREE.PlaneGeometry(CONFIG.photoSize + 0.15, (CONFIG.photoSize / aspect) + 0.15);
            const borderMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.1 });
            const border = new THREE.Mesh(borderGeo, borderMat);
            border.position.z = -0.02;
            mesh.add(border);

            scene.add(mesh);

            // Calc Positions
            const h = Math.random() * 0.8 + 0.1; // Keep photos in middle height
            const treePos = getTreePos(h, true).multiplyScalar(1.2); // Float slightly outside tree
            
            const scatterPos = new THREE.Vector3(
                (Math.random() - 0.5) * CONFIG.spreadRadius,
                (Math.random() - 0.5) * CONFIG.spreadRadius,
                (Math.random() - 0.5) * CONFIG.spreadRadius + 5
            );

            const obj = {
                mesh: mesh,
                treePos: treePos,
                scatterPos: scatterPos,
                originalScale: new THREE.Vector3(1,1,1),
                isPhoto: true
            };
            
            objects.push(obj);
            photos.push(obj);

            if (STATE.mode === 'tree') {
                gsap.fromTo(mesh.position, {x: scatterPos.x, y: scatterPos.y, z: scatterPos.z}, {x: treePos.x, y: treePos.y, z: treePos.z, duration: 2});
                mesh.lookAt(0, treePos.y, 0);
            } else {
                mesh.position.copy(scatterPos);
            }
        }

        // --- 4. ANIMATION CONTROLS (GSAP) ---

        function transitionToTree(duration = 1.5) {
            if (STATE.mode === 'tree' && duration > 0) return;
            STATE.mode = 'tree';
            STATE.activePhoto = null;

            objects.forEach(obj => {
                gsap.to(obj.mesh.position, {
                    x: obj.treePos.x,
                    y: obj.treePos.y,
                    z: obj.treePos.z,
                    duration: duration,
                    ease: "power2.inOut"
                });

                if (obj.isPhoto) {
                    // Photos face outward from center
                    const dummy = new THREE.Object3D();
                    dummy.position.copy(obj.treePos);
                    dummy.lookAt(0, obj.treePos.y, 0);
                    gsap.to(obj.mesh.rotation, {x: dummy.rotation.x, y: dummy.rotation.y, z: dummy.rotation.z, duration: duration});
                } else {
                    // Random clean rotation for clean tree look
                    gsap.to(obj.mesh.rotation, {x: Math.random(), y: Math.random(), z: Math.random(), duration: duration});
                }

                gsap.to(obj.mesh.scale, {
                    x: obj.originalScale.x, y: obj.originalScale.y, z: obj.originalScale.z, duration: 1
                });
            });

            // Reset Camera Orbit
            gsap.to(scene.rotation, { x: 0, y: 0, z: 0, duration: 1.5 });
        }

        function transitionToScatter() {
            if (STATE.mode === 'scatter') return;
            STATE.mode = 'scatter';
            STATE.activePhoto = null;

            objects.forEach(obj => {
                gsap.to(obj.mesh.position, {
                    x: obj.scatterPos.x,
                    y: obj.scatterPos.y,
                    z: obj.scatterPos.z,
                    duration: 2,
                    ease: "power3.out",
                    overwrite: "auto"
                });

                // Spin them while scattering
                gsap.to(obj.mesh.rotation, {
                    x: Math.random() * Math.PI * 2,
                    y: Math.random() * Math.PI * 2,
                    duration: 2.5
                });
                
                gsap.to(obj.mesh.scale, {
                    x: obj.originalScale.x, y: obj.originalScale.y, z: obj.originalScale.z, duration: 1
                });
            });
        }

        function zoomPhoto(photoObj) {
            if (STATE.mode === 'photo_zoom' && STATE.activePhoto === photoObj) return;
            STATE.mode = 'photo_zoom';
            STATE.activePhoto = photoObj;

            // Push background back
            objects.forEach(obj => {
                if (obj !== photoObj) {
                     gsap.to(obj.mesh.position, { z: obj.scatterPos.z - 15, duration: 1 });
                }
            });

            // Bring photo to camera
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const dist = STATE.isPortrait ? 8 : 5; // Further away on mobile so it fits
            const targetPos = camera.position.clone().add(camDir.multiplyScalar(dist));

            gsap.to(photoObj.mesh.position, {
                x: targetPos.x, y: targetPos.y, z: targetPos.z,
                duration: 1, ease: "back.out(1.2)"
            });

            gsap.to(photoObj.mesh.rotation, {
                x: camera.rotation.x, y: camera.rotation.y, z: camera.rotation.z,
                duration: 0.8
            });
            
            gsap.to(photoObj.mesh.scale, { x: 2.5, y: 2.5, z: 2.5, duration: 1 });
        }


        // --- 5. MEDIAPIPE & INTERACTION ---

        const videoElement = document.getElementById('video-input');
        const cursorEl = document.getElementById('hand-cursor');

        function onResults(results) {
            document.getElementById('loading').style.opacity = 0;
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                STATE.handVisible = true;
                const landmarks = results.multiHandLandmarks[0];

                // Detect Gestures
                const isFist = landmarks[8].y > landmarks[6].y && landmarks[12].y > landmarks[10].y;
                const isOpen = landmarks[8].y < landmarks[6].y && landmarks[12].y < landmarks[10].y && landmarks[16].y < landmarks[14].y;
                
                // Pinch detection (Index tip to Thumb tip)
                const pinchDist = Math.hypot(landmarks[8].x - landmarks[4].x, landmarks[8].y - landmarks[4].y);
                const isPinch = pinchDist < 0.08;

                // Cursor Position
                const indexTip = landmarks[8];
                const screenX = (1 - indexTip.x) * window.innerWidth;
                const screenY = indexTip.y * window.innerHeight;
                
                cursorEl.style.display = 'block';
                cursorEl.style.left = `${screenX}px`;
                cursorEl.style.top = `${screenY}px`;

                // Normalize for Raycaster (-1 to 1)
                STATE.cursor.x = ( (1 - indexTip.x) * 2 ) - 1;
                STATE.cursor.y = - ( indexTip.y * 2 ) + 1;

                // Logic Flow
                if (isFist) {
                    cursorEl.classList.remove('active');
                    transitionToTree();
                } else if (isOpen) {
                    if (STATE.mode !== 'photo_zoom') transitionToScatter();
                    
                    // Rotation Logic (Map Hand X position to Scene Rotation)
                    if (STATE.mode === 'scatter') {
                        // Deadzone in center to prevent jitter
                        const handX = 1 - landmarks[0].x; // 0 to 1
                        const rotSpeed = (handX - 0.5) * 4; 
                        gsap.to(scene.rotation, { y: scene.rotation.y + rotSpeed * 0.05, duration: 0.1 });
                    }
                }

                // Pinch / Interact
                if (isPinch) {
                    cursorEl.classList.add('active');
                    if (STATE.mode === 'scatter' || STATE.mode === 'photo_zoom') {
                        raycaster.setFromCamera(STATE.cursor, camera);
                        const photoMeshes = photos.map(p => p.mesh);
                        const intersects = raycaster.intersectObjects(photoMeshes);
                        if (intersects.length > 0) {
                            const hitObj = photos.find(p => p.mesh === intersects[0].object || p.mesh === intersects[0].object.parent);
                            if (hitObj) zoomPhoto(hitObj);
                        }
                    }
                } else {
                    cursorEl.classList.remove('active');
                }

            } else {
                cursorEl.style.display = 'none';
            }
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1, // Keep 1 for mobile performance
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });
        hands.onResults(onResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 320, height: 240
        });
        cameraFeed.start();


        // --- 6. RENDER LOOP ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // Passive animation
            if (STATE.mode === 'tree') {
                // Gentle sway of leaves/ornaments could go here, but rotation is enough for elegance
                scene.rotation.y += 0.001; 
            } else if (STATE.mode === 'scatter') {
                // Float particles
                const time = clock.getElapsedTime();
                objects.forEach((obj, i) => {
                    obj.mesh.position.y += Math.sin(time + i) * 0.005;
                });
            }

            composer.render();
        }
        animate();

        // Responsive Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            updateCameraPosition();
        });

    </script>
</body>
</html>
